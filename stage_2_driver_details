1. Driver

Your driver must have the following ELEVEN choices

Press option for the defined task

0. To exit from the loop (Ask for the choices in a loop)

1. For printing the token list generated by the lexer (on the console)

2. For parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console)

3. For printing the Abstract Syntax Tree in appropriate format. Also specify the traversal order at the beginning. (On Console)

4. For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used. The format should be as per the example given below

Parse tree Number of nodes = 150          Allocated Memory = 1024 Bytes

AST Number of nodes = 30                     Allocated Memory = 200 Bytes

Compression percentage = ((1024‐200)/1024)*100

(use sizeof() to compute size of allocated memory while allocate memory during construction of these trees)

5. For printing the Symbol Table in appropriate format showing all relevant information.[ Use width of integers as 2 and that of real numbers as 4]

6. For printing the list of global variables, their types and offsets (starts with 0)

7. For printing the total memory requirement (sum total of widths of all variables in the function scope) for each function. The format is as follows

                 _fun1                  18

                 _new                   34

                .... and so on              

8. For printing the type expressions and width of globally visible record definitions. Example format

              #new                int, real                       6

             #finance            int, real, int                 8

            and so on......

9. For compiling to verify the syntactic and semantic correctness of the input source code If the code is syntactically incorrect, report all syntax errors only. If the code is syntactically correct, then report all type checking and semantic errors. Also print (on the console) the total time taken by your integrated compiler. Print both total_CPU_time and total_CPU_time_in_seconds (as mentioned earlier)

10. For producing assembly code (Linux based NASM will be used for execution) (assuming that there is no syntactic, semantic or type mismatch errors in the test cases). 

 

Perform actions appropriately by invoking appropriate functions. All lexical, syntax and semantic errors including type mismatch errors must be reported appropriately on the console (Standard output) ONLY and not in any file unless otherwise specified.

 

The very first line on the console, as your compiler code executes, should contain a message regarding the status of your work such as

 

LEVEL #: Message

 

where # is any one index in {1,2,3,4} and the message is Symbol table/type Checking/ Semantic rules module(s) work(s) (specify one or many as applicable). The level specification is according to the total number of semantic rules you could successfully implement. The measure for the total number of semantic rules (type checking and semantic ) is as per the number of errors you could target. However, This level of message does not count on the syntax errors (which however are to be reported if exist).

 

Specify LEVEL as

1 , if less than or equal to 5 ERRORs out of all errors could be successfully handled

2 , if 6‐10 ERRORs could be implemented

3 , if 11‐15 ERRORs could be implemented

4 , if 16 or more ERRORs could be implemented

 

Note: If you print a message,

LEVEL 2: Symbol table/ AST/ Semantic Rules modules work.

This means that you were able to implement the symbol table, AST and semantic rules handling 6‐10 semantic errors in total, but you could not implement type checking successfully (subject to verification).

The complete ERROR list (with line numbers first) should be printed on the console if the code is syntactically or semantically incorrect, else print a message

Code compiles successfully..........

2. Compilation:

The name of the make file should be makefile only as I will avoid using ‐f option always to make your file named something else (that includes searching for the file which is time taking). The evaluation of your code will be done using the GCC version as specified earlier. Please ensure compatibility.

3. Execution

The command line argument for execution of the driver should be as follows, for example

$./compiler      testcase.txt       code.asm

where compiler is the executable generated after linking all the files (your makefile should be absolutely correct). Also, the testcase.txt is the input source code (in the language you are implementing) file to be compiled. code.asm is the output file containing the assembly language code (NASM ‐64 bits compatible) equivalent to the input source code. All errors including lexical errors, syntax errors and semantic errors should be displayed on the console with line numbers. Testing of the Resultant code in assembly language is done on a simulator NASM 2.14.02. The Instruction Set Architecture of NASM should be used for the target code.

